{"name":"Pegmatite","tagline":"A PEG library that rocks!","body":"Pegmatite design overview\r\n=========================\r\n\r\nThis is a fork and extensive rewrite of Achilleas Margaritis's ParserLib.  It\r\nhas the following goals:\r\n\r\n- Idiomatic C++11\r\n- Simple use\r\n- Reuseable, reentrant grammars with multiple action delegates\r\n- No dependency on RTTI / exceptions (usable in embedded contexts)\r\n\r\nIt has the following explicit non-goals:\r\n\r\n- High performance (ease of use or modification should not be sacrificed in the\r\n  name of performance)\r\n- Compatibility with the old ParserLib\r\n\r\nDesign outline\r\n--------------\r\n\r\nAll rules should be immutable after creation.  Ideally they'd be constexpr, but\r\nthis is likely not to be possible.  They should have no state associated with\r\nthem, however, and so parsing should be entirely reentrant.  State, for a\r\ngrammar, is in two categories:\r\n\r\n- The current parsing state\r\n- The actions to be performed when parsing\r\n\r\nThe actions can also be immutable (they don't change over a parse, at least),\r\nbut should not be tied to the grammar.  It should be possible to write one\r\nsingleton class encapsulating the grammar, with members for the rules, and\r\nsingleton subclasses (or, ideally, delegates) providing parser actions.  The\r\nparsing state should be entirely contained within a context object and so the\r\nsame grammar can be used from multiple threads and can be used for compilation,\r\nsyntax highlighting, and so on.\r\n\r\nDefining a grammar\r\n------------------\r\n\r\nYou can create freestanding `Rule` instances, however the recommended way of\r\ncreating a grammar is to place each rule inside a class.  The Calculator\r\nexample follows this pattern, with a `CalculatorGrammar` class containing one\r\nfield for each rule.  This is recommended for two reasons:\r\n\r\n 1) It allows lazy creation, rather than requiring the rules to be instantiated\r\n    on program creation.  This gives faster start-up times and means that\r\n    memory is only used when the grammar is actually used.\r\n 2) It improves encapsulation.  Although it is completely safe to refer to\r\n    rules in other grammars, placing them in a class makes it easy for people\r\n    binding actions to the grammar to identify all of the rules that they must\r\n    (or, might want to) provide actions for.\r\n\r\nSimple character or string recognising expressions can be created using the\r\n`_E` custom literal suffix.  For example `\"int\"_E` creates an expression that\r\nwill match the literal string \"int\".  This is useful for terminals.\r\n\r\nYou can define more complex operations from these by using the following\r\noperators (where `a` and `b` are expressions):\r\n\r\n - `*a` matches zero or more instances of `a`\r\n - `+a` matches one or more instances of `a`\r\n - `-a` matches zero or one instance of `a`\r\n - `a >> b` matches `a` and then `b`\r\n - `a | b` matches either `a` or `b`\r\n\r\nNewline rules have no special meaning in parsing, but are used to increment the\r\nline counter for input ranges.  If you declare a rule as matching a newline, it\r\nwill increment the line counter every time it is successfully matched.\r\n\r\nWhitespace rules allow implicit whitespace in between all non-terminal\r\nexpressions (sequences).\r\n\r\nBuilding an AST\r\n---------------\r\n\r\nThe `ASTContainer` class is intended to be used as the superclass for most AST\r\nnodes.  Any `ASTPtr` and `ASTList` fields of subclasses of this class will\r\nautomatically be created from the AST stack.  Each AST class that is\r\nconstructed is pushed onto the stack in the order that it is constructed and\r\nthen popped off by its parents.\r\n\r\nAST nodes do not, by default, keep around the `InputRange` of the text that\r\nthey matched.  This is to save space for cases where it is not required.  If\r\nyou intend to do helpful error reporting after semantic analysis, then it is\r\nstrongly recommended that you do keep such a reference.\r\n\r\nAfter you have defined your grammar and AST, all that remains is to bind the\r\ntwo together.  To do this, create a subclass of `ASTParserDelegate`, with one\r\n`BindAST` field for each AST node, initialised with the corresponding grammar\r\nrule.  The following is the parser for the Calculator example:\r\n\r\n\tclass CalculatorParser : public ASTParserDelegate\r\n\t{\r\n\t\tBindAST<AST::Number> num = CalculatorGrammar::get().num;\r\n\t\tBindAST<AST::AddExpression> add = CalculatorGrammar::get().add_op;\r\n\t\tBindAST<AST::SubtractExpression> sub = CalculatorGrammar::get().sub_op;\r\n\t\tBindAST<AST::MultiplyExpression> mul = CalculatorGrammar::get().mul_op;\r\n\t\tBindAST<AST::DivideExpression> div = CalculatorGrammar::get().div_op;\r\n\tpublic:\r\n\t\tconst CalculatorGrammar &g = CalculatorGrammar::get();\r\n\t};\r\n\r\nInvoking the `parse()` method on this class will cause an `AST::Number` class\r\nto be created for every terminal matching the `num` rule in the grammar, and so\r\non.  Note that this parser is reentrant.  It is safe to use it from multiple\r\nthreads to parse different strings.  It is therefore safe to also make the\r\nparser a singleton.\r\n\r\nRTTI Usage\r\n----------\r\n\r\nParserLib requires RTTI for one specific purpose: down-casting from `ast_node`\r\nto a subclass (and checking that the result really is of that class).  If you\r\nare using RTTI in the rest of your application, then you can instruct ParserLib\r\nto use RTTI for these casts by defining the `USE_RTTI` macro before including\r\nthe ParserLib headers and when building ParserLib.\r\n\r\nIf you do not wish to depend on RTTI, then ParserLib provides a macro that you\r\ncan use in your own AST classes that will provide the required virtual\r\nfunctions to implement ad-hoc RTTI for this specific use.  You use them like\r\nthis:\r\n\r\n\tclass MyASTClass : parserlib::ast_node\r\n\t{\r\n\t\t/* Your methods go here. */\r\n\t\tPARSELIB_RTTI(MyASTClass, parserlib::ast_node)\r\n\t};\r\n\r\nThis macro will be compiled away if you do define `USE_RTTI`, so you can\r\nprovide grammars built with ParserLib that don't force consumers to use or\r\nnot-use RTTI.  It is also completely safe to build without `USE_RTTI`, but\r\nstill compile with RTTI.\r\n\r\nWhat is Pegmatite\r\n-----------------\r\n\r\nPegmatite is a very crystalline, intrusive igneous rock composed of\r\ninterlocking crystals usually larger than 2.5 cm in size.\r\n\r\nIt is also a Parsing Expression Grammar library that rocks!\r\n\r\nTo do\r\n-----\r\n\r\nNot in order:\r\n\r\n- Write parameterised delegate for generating semantic HTML markup\r\n- Check whether the `USE_RTTI` setting for the headers and library had to match\r\n  it would be nice if it didn't...\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}